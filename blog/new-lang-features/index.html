<!doctype html>

<html lang=en>
  <head>
    <title>A Formal Commitment to New Language Features</title>

    <meta charset=utf8>
    <meta name=description content="JSHint, a JavaScript Code Quality Tool">
    <meta name=author      content="The JSHint team">

    

    
    <link rel=stylesheet href="/res/docs.min.css">
    

    <script>
      var _gaq = _gaq || [];
      _gaq.push(["_setAccount", "UA-126146-15"]);
      _gaq.push(["_setDomainName", "jshint.com"]);
      _gaq.push(["_trackPageview"]);
    </script>
  </head>

  <body>
    <nav class="header navbar navbar-default navbar-static-top" role="navigation">
  <div class="container">
    <div class="row">
      <div class="col-md-8">
        <div class="navbar-header">
          <a class="navbar-brand" href="/">JSHint</a>
        </div>

        <ul class="nav navbar-nav">
          <li><a href="/about/">About</a></li>
          <li><a href="/docs/">Docs</a></li>
          <li><a href="/install/">Install</a></li>
          <li><a href="/contribute/">Contribute</a></li>
          <li><a href="/blog/">Blog</a></li>
        </ul>
      </div>

      <div class="col-md-4">
        <form class="navbar-form navbar-left" role="search" onsubmit="return jumpToOption()">
          <div class="form-group">
            <input id="jump-to-option" type="text" class="form-control" placeholder="Option name">
          </div>
          <button type="submit" class="btn btn-default">Jump to docs</button>
        </form>
      </div>
    </div>
  </div>
</nav>




    <div class="container content">
      <div class="row">
        <div class="col-md-8">
          <h1 class="blog-title">A Formal Commitment to New Language Features</h1>

          <span class="blog-byline">
            <span class="blog-author">The JSHint team</span>
            <span class="blog-date">Jul 7th, 2015</span>
          </span>

          <p>In recent months, JSHint has been receiving requests to support <a href="https://github.com/tc39/ecma262">proposed
JavaScript language features</a> like
<a href="https://github.com/tc39/ecmascript-asyncawait"><code>async</code>/<code>await</code></a>, <a href="https://github.com/wycats/javascript-decorators">method
decorators</a>, and <a href="https://gist.github.com/jeffmo/054df782c05639da2adb">class
property declarations</a>
[<a href="#ref-1">1</a>]. The JSHint team has turned down each request, even after the
release of <a href="http://www.ecma-international.org/ecma-262/6.0/">ES2015</a>. This has
not been easy; as open source project maintainers, nothing gives us more
pleasure than to write code in benefit of our users. We&#39;ve tried to explain our
motivations in an ad-hoc way, but it&#39;s always come off as a bit haphazard. We&#39;d
like to take some time to more thoroughly describe our thought process.</p>

<p>The long and short of it is: JSHint will require all language extension
proposals to be at &quot;Stage 2&quot; of <a href="https://docs.google.com/document/d/1QbEE0BsO4lvl7NFTn5WXWeiEIBfaVUF7Dk0hpPpPDzU/edit?pli=1">TC-39&#39;s standardization
process</a>
before parsing and linting them.</p>

<h2>Why so defensive?</h2>

<p>Projects like <a href="https://github.com/google/traceur-compiler">Traceur</a> and
<a href="http://babeljs.io/">Babel</a> have become very popular through progressive
implementation of the latest features and proposals. It&#39;s fair to question why
JSHint should be any different.</p>

<p>First off, <strong>it&#39;s difficult for the project maintainers</strong>. This is not really a
defensible motivation; we only offer it in the interest of full disclosure.
Over the years, JSHint has grown from <a href="http://jslint.com/">JSLint</a> thanks to
the efforts of hundreds of contributors.  This has been key to its success, but
it has also contributed to a fair amount of technical debt. Extending the
parser requires a fair amount of study, and even then, it isn&#39;t always clear
how to do this cleanly.</p>

<p>The project has tried to be progressive about new syntax in the past
[<a href="#ref-2">2</a>], and this has often contributed to technical debt. For instance,
JSHint continues to
(<a href="https://github.com/jshint/jshint/pull/2519#issuecomment-118409190">grudgingly</a>)
maintain <a href="https://github.com/jshint/jshint/blob/e32e17b97289e4bb5a53116ffc3a979356792088/src/options.js#L466-L476">a <code>moz</code> option for Mozilla-specific
extensions</a>,
and the current <code>esnext</code> option includes non-standard array comprehensions. (By
the way: now that ES2015 is released, that name describes a non-existent
specification draft.)</p>

<p><a href="https://github.com/jshint/jshint/issues/2079">A plugin system</a> is one possible
way to address this, but that will require a large effort involving careful
design, spanning refactoring, and a long-term commitment to implementation
details.</p>

<p>More importantly, <strong>it&#39;s hazardous for developers</strong>. Inconsistencies within
toolchains will gate developers on the lowest common denominator. Imagine the
day that your transpiler supports draft 17 but JSHint has moved to draft 18.
Even if you&#39;re not struggling with coordination issues between parsers, the
release cycle for a &quot;progressive&quot; parser would leave most application
developers behind. Projects would frequently rely on outdated release channels
that no longer received bug fixes or new features.</p>

<p><a href="https://medium.com/@valueof/why-i-forked-jslint-to-jshint-73a72fd3612">JSHint was born out of a reluctance to make decisions on behalf of the
user</a>,
so while we think the above considerations should be made clear to JSHint&#39;s
users, we haven&#39;t made this decision based on them.</p>

<p>We also believe <strong>it&#39;s harmful for the ecosystem</strong>. Empowering developers to
write non-standard code can have long-term effects on the open source
ecosystem. Code has a tendency to live longer than we expect, but it isn&#39;t
always maintained throughout its lifetime. We all look forward to the day that
features like method decorators are standard and widely-supported. Prior to
that, it&#39;s important to remember that the code we write with experimental
language features is itself non-standard. It will be frustrating if, in 2
years, you are reviewing older code that seems to use &quot;standard&quot; function
decorators but that in reality depends on the syntax and semantics of &quot;revision
12&quot; of the function decorator proposal. The differences may be subtle, and you
will be forced to research the behavior of this not-quite-JavaScript before you
can contribute to the project.</p>

<p>Finally, <strong>it&#39;s unhealthy for the language</strong>. TC39 does not operate from an
ivory tower. They recognize practical considerations of patterns in existing
code.  Look no further than <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-additional-ecmascript-features-for-web-browsers">Annex
B</a>
for proof of that. Sometimes, that is a good thing. <a href="https://promisesaplus.com/">The Promises/A+
spec</a> offered a clear way forward when Promises
were first considered for inclusion in ES2015. Sometimes, this is a bad thing.
It&#39;s the reason why we expect
<a href="https://github.com/tc39/Array.prototype.includes/"><code>Array.prototype.includes</code></a>
instead of
<a href="https://esdiscuss.org/topic/having-a-non-enumerable-array-prototype-contains-may-not-be-web-compatible"><code>Array.prototype.contains</code></a>.
The proliferation of production code can have <a href="https://medium.com/@morrissinger/the-rise-of-the-bully-pulpit-in-the-evolution-of-javascript-94fb394d3b69">a solidifying
effect</a>
on new features. To the extent that JSHint is a channel through which new
JavaScript flows (a minuscule one to be sure), we want to cooperate with the
design process.</p>

<h2>So why stage 2?</h2>

<p>Stage 2 seems specifically designed for our position in the ecosystem.</p>

<p>It&#39;s not too early. Features in this stage have a formal definition (so we have
a consistent and complete set of instructions to build from). These features
are also relatively stable, so JSHint has a chance to keep up with the latest
draft modifications.</p>

<p>It&#39;s also not too late. The design process can still benefit from the
experience of developers applying a given pattern to their code. The process
document defines &quot;incremental&quot; changes expected for Stage 2 proposals, and only
recommends &quot;experimental&quot; implementations. You might say, &quot;<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=258974#c22">these features seem
stable enough</a>&quot;, but
the truth is, JSHint was dealing with non-trivial modifications to ES2015 from
the moment we implemented them until as late as May of this year [<a href="#ref-3">3</a>].
So it&#39;s worth noting that JSHint is <em>still</em> taking some risk here.</p>

<p>We think there&#39;s tremendous value in experimentation at earlier stages in the
process. We also feel that research should be conducted in non-production
settings in order to avoid the more fundamental problems discussed above.
Early-stage experiments have less to gain from automated code analysis both
because of their limited scope and because their syntax is already verified by
a &quot;transpiler&quot;. In these contexts, linting has much more limited relevance.</p>

<h2>Moving forward</h2>

<p>Here&#39;s the practical effect of all that talk:</p>

<ul><li>JSHint 3 will not expose an <code>esnext</code> option; it will instead support
<code>esversion: 6</code>.</li><li>JSHint will continue to support the <code>moz</code> option, and it will be the only
setting that enables array comprehension parsing.</li><li>JSHint will <em>not</em> expose an <code>esversion: 7</code> option until that specification is
finalized by ECMA.</li><li>JSHint will support for stage-2-and-above proposals under the <code>experimental</code>
configuration namespace. These features will be clearly documented as subject
to breaking changes between major releases.</li></ul>

<p>This policy means denying first-class support for non-standard and early
proposal features. JSHint will continue to support <code>ignore</code> directives as a
coarse-grained mechanism for operating on non-standard and early-proposal
features, but we know <a href="https://github.com/babel/babel-eslint">other linting tools go much farther than
that</a>. We&#39;re motivated by our
responsibility to developers but also to the open source ecosystem and to the
standards process itself. We hope JSHint&#39;s usership continues to enjoy the tool
because they share these same values.</p>

<hr/>

<span id="ref-1">
[1] Requests for proposed language features:

<ul><li><a href="https://github.com/jshint/jshint/pull/1977">gh-1977 WIP: Async/await</a></li><li><a href="https://github.com/jshint/jshint/pull/1979">gh-1979 Added optional asyncawait support on top of
esnext</a></li><li><a href="https://github.com/jshint/jshint/pull/2077">gh-2077 AsyncAwait plugin</a></li><li><a href="https://github.com/jshint/jshint/issues/2297">gh-2297 Please add support for ES7 method
decorators</a></li><li><a href="https://github.com/jshint/jshint/issues/2304">gh-2304 ES7 Class Properties throws &#39;Unexpected token
=&#39;</a></li><li><a href="https://github.com/jshint/jshint/issues/2309">gh-2309 class property initializers
proposal</a></li><li><a href="https://github.com/jshint/jshint/issues/2310">gh-2310 Support for ES7
decorators?</a></li><li><a href="https://github.com/jshint/jshint/issues/2504">gh-2504 ES7: async and await</a></li></ul>

</span>

<span id="ref-2">
[2] Introduction of ES6 features

<ul><li><a href="https://github.com/jshint/jshint/pull/971">gh-971 Arrow functions</a> (13.03.28)</li><li><a href="https://github.com/jshint/jshint/pull/1048">gh-1048 ES6 classes</a> (13.05.19)</li><li><a href="https://github.com/jshint/jshint/pull/1608">gh-1608 Support ModuleImport
expressions</a> (14.04.05)</li><li><a href="https://github.com/jshint/jshint/pull/1563">gh-1563 Add basic support for ES6
TemplateLiterals</a> (14.03.21)</li></ul>

</span>

<span id="ref-3">
[3] Issues involving changes to the spec:

<ul><li><a href="https://github.com/jshint/jshint/issues/1123">gh-1123 A generator function shall contain a yield
statement.</a></li><li><a href="https://github.com/jshint/jshint/issues/1936">gh-1936 ES6 (<code>esnext</code>) error: `import * as foo from
&#39;bar&#39;</a></li><li><a href="https://github.com/jshint/jshint/issues/2019">gh-2019 ES6 classes with export default flagged as &#39;not
defined&#39;</a></li><li><a href="https://github.com/jshint/jshint/pull/2144">gh-2144 Support more cases of ES6 module
usage</a></li><li><a href="https://github.com/jshint/jshint/issues/2197">gh-2197 ES6 (esnext:true), jshint says &quot;Foo is not defined&quot;... but it&#39;s
defined!</a></li><li><a href="https://github.com/jshint/jshint/issues/2395">gh-2395 jshint incorrectly supports the module x from &#39;y&#39;
format?</a></li></ul>

</span>

        </div>
      </div>
    </div>

    <script>
      (function () {
        var ga = document.createElement("script");
        ga.type = "text/javascript";
        ga.async = true;
        ga.src = "//www.google-analytics.com/ga.js";

        var st = document.getElementsByTagName("script")[0];
        st.parentNode.insertBefore(ga, st);
      })();
    </script>
  </body>
</html>
